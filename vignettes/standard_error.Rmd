---
title: "Multiple Imputation"
author: "Thomas Leeper"
output:
  html_document: default
  html_notebook: default
---

```{r setup, include=FALSE, error=TRUE, message=FALSE}
knitr::opts_chunk$set(echo = TRUE, comment = NA, error = TRUE)
```

This tutorial covers techniques of multiple imputation. Multiple imputation is a strategy for dealing with missing data. Whereas we typically (i.e., automatically) deal with missing data through casewise deletion of any observations that have missing values on key variables, imputation attempts to replace missing values with an estimated value. 

In `single imputation`, we guess that missing value one time (perhaps based on the means of observed values, or a random sampling of those values). In `multiple imputation`, we instead draw multiple values for each missing value, effectively <u>building multiple datasets</u>, each of which replaces the missing data in a different way. 

There are numerous algorithms for this, each of which builds those multiple datasets in different ways. We're not going to discuss the details here, but instead **focus on executing multiple imputation in R**. The main challenge of multiple imputation is not the analysis (it simply proceeds as usual on each imputed dataset) but instead the aggregation of those separate analyses. The examples below discuss how to do this.

To get a basic feel for the process, let's imagine that we're trying to calculate the mean of a vector of values that contains missing values. We can impute the missing values by drawing from the observed values, repeat the process several times, and then average across the `estimated means` to get an estimate of the mean with a measure of uncertainty that accounts for the `uncertainty due to imputation`. Let's create a vector of ten values, seven of which we observe and three of which are missing, and imagine that they are random draws from the population whose mean we're trying to estimate:

Source: http://thomasleeper.com/Rcourse/Tutorials/mi.html

```{r}
n <- 10            # "n" values; vector of "n" length
bad <- 3           # number of NAs
good <- n - bad    # valid values

set.seed(10)

x <- c(sample(1:n, good, replace = TRUE), rep(NA, bad))  # build vector of "n" lements
x
```

```{r}
plot(x, col = "blue")
```


We can find the mean using case deletion:

```{r}
mean(x, na.rm = TRUE)
```

Our estimate of the sample `standard error` is then:

```{r}
# Standard Error of only the elements that are not NA
sum(!is.na(x))
sd(x, na.rm = TRUE) / sqrt(sum(!is.na(x)))
```

### impute with random values
Now let's impute several times to generate a list of imputed vectors:

```{r}
# Generate 15 samples of new data replacing the NA elements with values 
# extracted from the GOOD values.

na.count <- length(x[is.na(x) == TRUE])    # calculate the # of NAs

imp <- replicate(15, 
                 c(x[!is.na(x)],                           # get the 7 non-NA elements
                   sample(x[!is.na(x)], na.count, TRUE)),  # get 3 elements from non-NA vec
                 simplify = FALSE)                         # output to be a vector
imp
```

```{r}
plot(imp[[1]])
```

```{r}
library(zoo)

St <- x

Sti <- na.locf(x)
nas.count(Sti)
par(mfrow=c(1,1))
limRow <- length(x)

colvec <- ifelse(is.na(St), mdc(2), mdc(1))    # missing data coloring (Mdc)

plot(Sti[1:limRow], 
     col = colvec, 
     type="l", 
     xlab="Observation", 
     ylab="Value")

points(Sti[1:limRow], col = colvec, pch=20, cex=2)
# points(imp[[1]], col = colvec, pch=21, cex=1.5)
# points(imp[[2]], col = colvec, pch=22, cex=1.5)
# points(imp[[3]], col = colvec, pch=23, cex=1.5)
# points(imp[[4]], col = colvec, pch=24, cex=1.5)
# points(imp[[5]], col = colvec, pch=25, cex=1.5)

for (i in 1:length(imp)) {
  points(imp[[i]], col = colvec, pch=i, cex=1)
}
```


The result is a list of fifteen vectors. The first seven values of each is the same as our original data, but the three missing values have been replaced with different combinations of the observed values. 

To get our new `estimated mean`, we simply take the mean of each vector, and then average across them:

```{r}
means <- sapply(imp, mean)
means
```

```{r}
# the grand mean or the mean of all means
grandm <- mean(means)
grandm
```

The result is 4.147, about the same as our original estimate. To get the standard error of our multiple imputation estimate, we need to combine the `standard errors` of each of our estimates, so that means we need to start by getting the SEs of each imputed vector:
```{r}
# standard error
ses <- sapply(imp, sd) / sqrt(10)
ses
```

Aggregating the standard errors is a bit complicated, but basically sums the mean of the SEs (i.e., the “within-imputation variance”) with the variance across the different estimated means (the “between-imputation variance”). To calculate the within-imputation variance, we simply average the SE estimates:

```{r}
within <- mean(ses)
within
```

To calculate the between-imputation variance, we calculate the sum of squared deviations of each imputed mean from the grand mean estimate:

```{r}
between <- sum((means - grandm)^2)/(length(imp) - 1)
between
```

Then we sum the within- and between-imputation variances (multiply the latter by a small correction):

```{r}
grandvar <- within + ((1 + (1/length(imp))) * between)
grandse <- sqrt(grandvar)
grandse
```

The resulting standard error is interesting because we **increase the precision of our estimate by using 10 rather than 7 values** (and standard errors are proportionate to sample size), but is larger than our original standard error because we have to account for uncertainty due to imputation. Thus, if our missing values are truly missing at random, we can get a better estimate that is actually representative of our original population. Most multiple imputation algorithms are, however, applied to multivariate data rather than a single data vector and thereby use additional information about the relationship between observed values and missingness to reach even more precise estimates of target parameters.

```{r}

```

