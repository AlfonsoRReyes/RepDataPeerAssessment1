---
title: "Multiple Imputation"
output:
  html_document: default
  html_notebook: default
---

```{r setup, include=FALSE, error=TRUE, message=FALSE}
knitr::opts_chunk$set(echo = TRUE, comment = NA, error = TRUE)
```

Source: http://thomasleeper.com/Rcourse/Tutorials/mi.html

```{r}
n <- 10
bad <- 3
good <- n - bad

set.seed(10)
x <- c(sample(1:n, good, replace = TRUE), rep(NA, bad))
x
```

```{r}
mean(x, na.rm = TRUE)
```

Standard Error of only the elements that are not NA:
```{r}
sd(x, na.rm = TRUE) / sqrt(sum(!is.na(x)))
```
Generate 15 samples of new data replacing the NA elements with values extracted from the GOOD values.



```{r}
na.count <- length(x[is.na(x) == TRUE])    # calculate the # of NAs

imp <- replicate(15, 
                 c(x[!is.na(x)],                           # get the 7 non-NA elements
                   sample(x[!is.na(x)], na.count, TRUE)),  # get 3 elements from non-NA vec
                 simplify = FALSE)                         # output to be a vector
imp
```


## Applying the concept to the `activity` dataset
The dataset has to be transformed and put the intervals as variables and the steps as values. The date is the ID or index.

```{r}
library(reshape)
library(RepDataPeerAssessment1)

data(activity)

#activity$interval <- as.factor(activity$interval)
names(activity) <- c("value", "date", "interval")
actbycol <- cast(activity, date ~ interval)
```




```{r results='hold'}
cat("# of variables:", (ncol(actbycol)), "\t")
cat("# of intervals:", (ncol(actbycol)-1))
cat("\n")
mysample <- actbycol[sample(1:nrow(actbycol), 10, replace=FALSE), c(1:7, 283:289)]
mysample
```

```{r}
splice <- list(rows = c(1:5, 57:61), cols = c(1:5, 286:289))
mysample <- actbycol[splice$rows, splice$cols]
mysample
```


### Starting with interval `0` of activity by intervals
In our case, the vector to investigate is any of the interval columns.
Let's start with interval 0 assigning it as a vector.

```{r}
x0 <- actbycol$`0`
x0
```

The mean is:
```{r}
mean(x0, na.rm = TRUE)
```
The standard error:
```{r}
sd(x0, na.rm = TRUE) / sqrt(sum(!is.na(x0)))
```

```{r}
x <- x0
na.count <- length(x[is.na(x) == TRUE])    # calculate the # of NAs

imp <- replicate(15, 
                 c(x[!is.na(x)],                           # get the 7 non-NA elements
                   sample(x[!is.na(x)], na.count, TRUE)),  # get 3 elements from non-NA vec
                 simplify = FALSE)                         # output to be a vector
imp
```

  
```{r}
calcAfter <- function(x, samples = 15) {
  na.count <- length(x[is.na(x) == TRUE])    # calculate the # of NAs

  imp <- replicate(samples, c(x[!is.na(x)],
                     sample(x[!is.na(x)], na.count, TRUE)),  
                   simplify = FALSE)                  
  
  means <- sapply(imp, mean)
  grandm <- mean(means)
  
  ses <- sapply(imp, sd)/sqrt(10)
  within <- mean(ses)
  between <- sum((means - grandm)^2)/(length(imp) - 1)
  
  grandvar <- within + ((1 + (1/length(imp))) * between)
  grandse <- sqrt(grandvar)
  
  list(grandMeans = grandm, grandSE = grandse)
}
```


```{r}
calcAfter(x0, 15)
```


Now, let's see if something changed:

```{r}
means <- sapply(imp, mean)
means
```

```{r}
grandm <- mean(means)
grandm
```

```{r}
ses <- sapply(imp, sd)/sqrt(10)
within <- mean(ses)
between <- sum((means - grandm)^2)/(length(imp) - 1)

grandvar <- within + ((1 + (1/length(imp))) * between)
grandse <- sqrt(grandvar)
grandse
```

### Applying on interval `5` but with a function

```{r}
calcBefore <- function(x) {
  na.count <- length(x[is.na(x) == TRUE])    # calculate the # of NAs
  notna.count <- length(x[is.na(x) == FALSE]) 
  mean <- mean(x, na.rm = TRUE)
  serror <- sd(x, na.rm = TRUE) / sqrt(sum(!is.na(x)))
  list(notna = notna.count, na = na.count, mean = mean, stdError = serror)
}
```

```{r}
calcBefore(x0)
```

```{r}
x5 <- actbycol$`5`
calcBefore(x5)
calcAfter(x5)
```

```{r}
x10 <- actbycol$`10`
calcBefore(x10)
calcAfter(x10)
```


```{r}
x25 <- actbycol$`25`
calcBefore(x25)
calcAfter(x25)
```



## `lapply` example
```{r}
y <- list(a = 1:5, b = rnorm(10))
y
lapply(y, mean)
```
## `sapply` example

```{r}
y <- list(a = 1:5, b = rnorm(10))
y
sapply(y, mean)
```

## Vectorizing functions

```{r}
# subset of only the numerical data, no date
actbycol2 <- actbycol[, 2:289]
```


Applying a function to all the dataframe, excluding the date""
```{r}
sapply(actbycol2, calcBefore)
```
### Calculating the Standard Error

```{r}
sapply(actbycol2, calcAfter)
```




```{r}
hist(activity$value)
```
### histogram of activity without zeros
```{r}
activity.nonzero <- subset(activity, activity$value > 0)
hist(activity.nonzero$value)
```
### Histogram of activity restored from cast() 
```{r}
actbycol.melt <- melt(actbycol, id = "date")
rownames(actbycol.melt) <- NULL
hist(subset(actbycol.melt, actbycol.melt$value > 0)$value)
```


## Function to imputting NA with random values
```{r}
random.imp <- function (a){
  missing <- is.na(a)        # logical vector. TRUE for NAs
  n.missing <- sum(missing)  # number of missing values
  a.obs <- a[!missing]       # vector of GOOD values
  imputed <- a               # copy of original vector
  
  # Take a sample from GOOD part of the vector and replace missing elements
  imputed[missing] <- sample (a.obs, n.missing, replace=TRUE)
  return (imputed)           # return complete vector
}
```

```{r}
x
```

```{r}
missing <- is.na(x)
missing
```
```{r}
n.missing <- sum(missing)
n.missing
```
```{r}
x.obs <- x[!missing]
x.obs
```

```{r}
imputed <- x
imputed
```

```{r}
imputed[missing] <- sample (x.obs, n.missing, replace=TRUE)
imputed
```


### Running function on a vector

```{r}
random.imp(x)
```

### Running function on 1st interval of `actbycol2`

```{r}
x0
random.imp(x0)
```

```{r}
actbycol2[splice$rows, splice$cols-1]
```

```{r}
actbycol.rep <- random.imp(actbycol2[, 1:10])
```

```{r}
actbycol2[splice$rows, splice$cols-1]
```

### numerical dataframe with replaced random values

```{r}
actbycol.imp <- random.imp(actbycol2)    
actbycol.imp[splice$rows, splice$cols-1]
```



```{r}
date <- actbycol[, 1]
actbycol.bind <- cbind(date, actbycol.imp)
```



```{r}
actbycol.imp.melt <- melt(actbycol.bind, id = "date")
names(actbycol.imp.melt) <- c("date", "interval", "steps")
# rownames(actbycol.melt) <- NULL
hist(subset(actbycol.imp.melt, actbycol.imp.melt$steps > 0)$steps)
#hist(actbycol.imp.melt$steps)
```


## Mean Imputation
```{r}
# activity$interval <- as.numeric(activity$interval)
names(activity) <- c("steps",    "date",     "interval")
```


```{r}
library(lattice)
library(mice)

data(activity)

activity.nodate <- activity[, c(1, 3)]

### impute the mean
#imp <- mice(activity.nodate, method="mean", m=1, maxit=1)
imp <- mice(activity.nodate, method="mean", m=1, maxit=1)
```

```{r}
### Figure 1.1
lwd <- 1.5
# par(mfrow=c(1,2))

max <- max(nas.complete(activity$steps))

breaks <- seq(0, max*1.1, 20)
nudge <- 1

x <- matrix(c(breaks-nudge, breaks+nudge), ncol=2)

obs <- activity[, "steps"]
mis  <- imp$imp$steps[,1]

fobs <- c(hist(obs, breaks, plot=FALSE)$counts, 0)
fmis <- c(hist(mis, breaks, plot=FALSE)$counts, 0)

y <- matrix(c(fobs, fmis), ncol=2)

matplot(x, y, type="s",
        col=c(mdc(4),mdc(5)), lwd=2, lty=1,
        #xlim = c(0, 170), 
        ylim = c(-5, 200), 
        yaxs = "i",
        xlab="Steps",
        ylab="Frequency")
# box()


```

```{r fig.asp=1}
tp <- xyplot(imp, steps~interval, 
             na.groups = ici(imp), 
             ylab ="steps", xlab="interval",
       cex = 0.75, 
       
       lex=lwd
       #ylim = c(0, 900), 
       #xlim = c(0, 500))
)
#print(tp, newpage = FALSE, position = c(0.48,0.08,1,0.92))
tp
```

## Regression Imputation
```{r}

fit <- lm(steps ~ interval, data=activity)
pred <- predict(fit, newdata=ic(activity))

### alternative using mice
imp <- mice(activity[,c(1,3)], method="norm.predict", m=1, maxit=3,seed=1)
```

```{r}
### Figure 1.2
par(mfrow = c(1,2))

fmis <- c(hist(pred, breaks, plot=FALSE)$counts, 0)
y <- matrix(c(fobs, fmis), ncol=2)

matplot(x, y, type="s",
        col=c(mdc(4),mdc(5)), lwd=2, lty=1,
        ylim = c(0, 200),
        yaxs = "i",
        xlab="steps",
        ylab="Frequency")
box()

tp <- xyplot(imp, steps~interval,
       ylab="steps", xlab="interval",
       cex = 0.75, lex=lwd,
)
print(tp, newpage = FALSE, position = c(0.48,0.08,1,0.92))
```


## Stochastic regression imputation

```{r}

library(lattice)
library(mice)

imp <- mice(activity[,c(1,3)], method="pmm", m=1, maxit=3, seed=1)

lwd <- 2
nudge <- 1
### Figure 1.3
par(mfrow = c(1,2))

mis  <- imp$imp$steps[,1]

breaks <- seq(-500, 900, 10)

obs <- activity[,"steps"]

fobs <- c(hist(obs, breaks, plot=FALSE)$counts, 0)
fmis <- c(hist(mis, breaks, plot=FALSE)$counts, 0)

x <- matrix(c(breaks-nudge, breaks+nudge), ncol=2)
y <- matrix(c(fobs, fmis), ncol=2)

matplot(x, y, type="s",
        col=c(mdc(4),mdc(5)), lwd=2, lty=1,
        ylim = c(0, 300),
        yaxs = "i",
        xlab="steps",
        ylab="Frequency")

box()

tp <- xyplot(imp, steps~interval, na.groups=ici(imp),
       ylab="steps", xlab="interval",
       cex = 0.75, lex=lwd,
       )
# tp
print(tp, newpage = FALSE, position = c(0.48,0.08,1,0.92))
```

## LOCF

```{r}
library(lattice)
library(mice)
library(zoo)

St <- activity$steps

locf <- function(x) {
  # last observation carried forward
  NonNAindex <- which(!is.na(x))  # find the index of all non-NAs
  firstNonNA <- min(NonNAindex)   # get the lower index or 1st non-NA
  a <- x[firstNonNA]              # assign 1st non-NA observation to pivot
  
  for (i in 1:length(x)) {        # count from the 2nd to the end of the vector
    if (is.na(x[i])) x[i] <- a    # if current element is NA, then make it as pivot
    else a <- x[i]                # else make pivot same as ith
  }
  return(x)
}

Sti <- locf(St)
nas.count(Sti)
colvec <- ifelse(is.na(St), mdc(2), mdc(1))

### Figure 1.4

limRow <- 12000

plot(Sti[1:limRow], 
     col = colvec, 
     type="l", 
     xlab="Observation", 
     ylab="Steps")

points(Sti[1:limRow], col = colvec, pch=20, cex=1)
```

```{r}
### Figure 1.4

library(zoo)

St <- activity$steps

Sti <- na.locf(St)
nas.count(Sti)
par(mfrow=c(1,1))
limRow <- 12000

colvec <- ifelse(is.na(St), mdc(2), mdc(1))    # missing data coloring (Mdc)

plot(Sti[1:limRow], 
     col = colvec, 
     type="l", 
     xlab="Observation", 
     ylab="Steps")

points(Sti[1:limRow], col = colvec, pch=20, cex=1)
```


